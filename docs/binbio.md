# バイナリ生物学のGB向け実装について
- バイトオーダーはリトルエンディアン

## データ構造
### `cell`: 細胞
| オフセット | 名前 | 内容 | 型 | 初期細胞[^init_cell]の値 |
| --- | --- | --- | --- | --- |
| 0 | `flags` | フラグ | ビットフィールド(1バイト) | 0x01 |
| 1 | `tile_x` | タイル座標(X) | 符号なし整数(1バイト) | 0x0a(10) |
| 2 | `tile_y` | タイル座標(Y) | 符号なし整数(1バイト) | 0x09 |
| 3 | `life_duration` | 寿命 | 符号なし整数(1バイト) | 0x0a(10) |
| 4 | `life_left` | 余命 | 符号なし整数(1バイト) | 0x0a(10) |
| 5 | `fitness` | 適応度 | 符号なし整数(1バイト) | 0x64(100) |
| 6 | `tile_num` | タイル番号 | 符号なし整数(1バイト) | 0x8b(細胞タイル) |
| 7 | `bin_size` | 機械語バイナリサイズ | 符号なし整数(1バイト) | 0x05 |
| 8 | `bin_data` | 機械語バイナリ | 機械語バイナリ列(5バイト) | 0x3e 8b cd <TBD[^a_set_tile_num_to_cell]>(現在の細胞のタイル番号を変更する関数のアドレス) |
| 13 | `collected_flags` | 機械語バイナリの各バイトの取得フラグ | ビットフィールド(1バイト) | 0x00 |
- サイズ：14バイト
[^init_cell]: 開始時に存在する細胞
[^a_set_tile_num_to_cell]: 指定されたタイル番号を現在注目している細胞へ設定する関数のアドレス(2バイト)

#### `flags`: フラグ
| ビット | 名前 | 内容 | 初期細胞の値 |
| --- | --- | --- | --- |
| 7-1 | - | 予約 | 0b0000 000 |
| 0 | `alive` | この細胞が生きている(=1)か否(=0)か | 1 |

#### `tile_x`・`tile_y`: タイル座標(X,Y)
- 8x8pxのタイル何個目か(0始まり)で表す座標系
- GBの背景マップサイズは256x256pxなので、タイル座標として取り得る値はX・Y共に0(0x00)〜31(0x1f)
  - その内、表示領域は160x144pxなので、表示されるのは20(0x14)x18(0x12)個のタイルの領域
- 変換式
  - ※ TILE_WIDTH = TILE_HEIGHT = 8
  - ピクセル座標(Px,Py) → タイル座標(Tx,Ty)
    - Tx = Px / TILE_WIDTH (小数点以下切り捨て)
    - Ty = Py / TILE_HEIGHT (小数点以下切り捨て)
  - タイル座標(Tx,Ty) → ピクセル座標(Px,Py)
    - Px = Tx * TILE_WIDTH
    - Py = Ty * TILE_HEIGHT
    - ※ この時、(Px,Py)は該当タイルの左上座標

#### `bin_data`: 機械語バイナリ
- `ret`命令は含まない
  - 「代謝/運動」時に実行用の領域へコピーし、その際に末尾にret命令を追加する

#### `collected_flags`: 機械語バイナリ列の各バイトの取得フラグ
- 下位のビットから順に`bin_data`の1バイト目、2バイト目、3バイト目、・・・の取得済みを示すフラグ

### システム定数
| 名前 | 内容 | 型 |
| --- | --- | --- |
| `NULL` | ヌルポインタ(0x0000) | アドレス(2バイト) |
| `CELL_DATA_AREA_BEGIN` | 細胞データ領域の最初のアドレス | アドレス(2バイト) |
| `CELL_DATA_AREA_END` | 細胞データ領域の最後のアドレス | アドレス(2バイト) |
| `CELL_DATA_SIZE` | 細胞データ構造のサイズ[バイト] | 符号なし整数(1バイト) |

### システム変数
| 名前 | 内容 | 型 | 初期値 |
| --- | --- | --- | --- |
| `cur_cell` | 現在対象としている細胞番号 | 符号なし整数(1バイト) | 初期細胞の細胞番号(0) |
| `cur_cell_addr` | 現在対象としている細胞アドレス | アドレス(2バイト) | 初期細胞のアドレス |
| `mutation_probability` | 突然変異確率(0〜100) | 符号なし整数(1バイト) | 50 |

### 備考
- 細胞番号と細胞アドレスの関係
  - 細胞データ領域先頭アドレス + (細胞番号 * 細胞データ構造サイズ(16バイト)) = 細胞アドレス

## 振る舞い
### `death`: 死
- 処理内容
  - 現在の細胞の`alive`フラグをクリアする

### `growth`: 成長
- 引数
  | レジスタ | 内容 |
  | --- | --- |
  | A | 取得したコード化合物 |
- 処理内容
  - 現在の細胞の`bin_data`の中に「取得したコード化合物」と同じものが存在したら、対応する`collected_flags`のビットをセットする

### `is_dividable`: 分裂可能か？
- 戻り値
  | レジスタ | 内容 |
  | --- | --- |
  | A | 分裂可能なら1、そうでないなら0 |
- 処理内容
  - 現在の細胞の`collected_flags`の`bin_data`に対応する全てのビットがセットされていたら分裂可能

### `alloc`: 細胞データ領域を確保
- 戻り値
  | レジスタ | 内容 |
  | --- | --- |
  | A | 確保した領域のアドレス(確保できなかった場合は`NULL`) |
- 処理内容
  1. `CELL_DATA_AREA_BEGIN`から`CELL_DATA_SIZE`バイト毎に`flags`.`alive`が0の場所を探す
  2. 見つけた領域のアドレスをレジスタAへ設定しreturn
  3. `CELL_DATA_AREA_END`まで到達しても見つからなかった場合、レジスタAへ`NULL`を設定しreturn

### `find_free_neighbor`: 近傍の空き座標を探す
- 戻り値
  | レジスタ | 内容 |
  | --- | --- |
  | A | 見つけたX座標(見つからなかった場合は0xff) |
  | B | 見つけたY座標(見つからなかった場合は0xff) |
- 処理内容
  1. `cur_cell_addr`から現在の細胞データを参照し`tile_x`・`tile_y`を取得
  2. 現在の細胞の8近傍を左上から順に時計回りでチェック
  3. 何も配置されていない座標を見つけたら、その座標をレジスタA・Bへ設定しreturn
     - その座標に何か配置されているか否かは、0xdc00以降のタイルミラー領域をチェックすることで行う
  4. 何も配置されていない座標が見つからなかった場合は、レジスタA・Bへ共に0xffを設定しreturn

### `division`: 分裂
- 方針
  - 突然変異は`bin_data`の2バイト目(タイル番号)のみで行う
- 処理内容
  1. 細胞データ領域を確保(`alloc`)
     - 確保できなかった場合、ここでreturnする
  2. 近傍の空き座標を探す(`find_free_neighbor`)
     - 近傍に空き座標が無かった場合、ここでreturnする
  3. `mutation_probability`に従って突然変異するか否かを決める
     - 突然変異する場合、新たな`bin_data`の2バイト目を算出する
  4. 確保した領域へ細胞データを設定
     | 名前 | 設定値 |
     | --- | --- |
     | `flags` | 0x01 |
     | `tile_x`, `tile_y` | 2.で見つけた座標 |
     | `life_duration` | 親の`life_duration` |
     | `life_left` | 親の`life_duration` |
     | `fitness` | 親の`fitness` |
     | `tile_num` | 親の`tile_num` |
     | `bin_size` | 親の`bin_size` |
     | `bin_data` | 親の`bin_data`(ただし突然変異する場合、2バイト目は3.で算出した値を使う) |
     | `collected_flags` | 0x00 |
