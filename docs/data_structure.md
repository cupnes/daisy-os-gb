# 各種のデータ構造と振る舞いについて
※ バイトオーダーはリトルエンディアン

## 画像
### データ構造
| オフセット | 名前 | 内容 | サイズ[バイト] |
| --- | --- | --- | --- |
| 0 | `tile_def_area_size` | タイル定義領域サイズ | 2 |
| 2 | `tile_def_area` | タイル定義領域 | `tile_def_area_size` |
| 2 + `tile_def_area_size` | `img_def_area` | 画像定義領域 | 360 (20 * 18[タイル]) |

#### タイル定義領域サイズ
現状、4096バイト(256タイル)を超えるサイズには未対応。

#### タイル定義領域
1つ16バイトのタイルデータを定義する。この領域の内容をVRAMのタイルパターンテーブル(0x8000〜)へコピーする。そのため、この領域のタイルのタイル番号は0から順に採番される。

#### 画像定義領域
20 * 18タイルの1画面分の各タイル番号を定義する。

なお、スクリーンサイズ(32 * 32タイル)で定義しているわけではないので、この領域をそのままVRAMの背景マップ領域へコピーしてはいけない。1行毎に非表示の12タイル分を飛ばす必要がある。

### 振る舞い
#### `view_img()`: 指定されたファイル番号の画像を表示する
- 引数
  | レジスタ | 内容 |
  | --- | --- |
  | A | ファイル番号 |
- 戻り値
  | レジスタ | 内容 |
  | --- | --- |
  | A | ステート番号<br>- 0x00: tdq消費待ち<br>- 0x01: 画像表示完了 |
- 処理内容
  1. `tdq.stat`にemptyフラグはセットされているか?
     - セットされていない場合、レジスタAにステート番号として0x00(tdq消費待ち)を設定してreturn
       - ∵ 画像表示から戻る際、元の状態としてタイルミラー領域を参照するため、事前にtdqの内容を描画させ切る
  2. 指定されたファイル番号に対応するファイルデータアドレスを取得
  3. V-Blankの開始を待ち、LCDを停止
  4. タイル定義領域の内容をVRAMのタイルパターンテーブル(0x8000〜)へコピー
  5. 画像定義領域の内容をVRAMの背景マップ領域へ1行ずつコピー
  6. LCD再開
  7. レジスタAにステート番号として0x01(画像表示完了)を設定してreturn

#### `quit_img()`: 画像表示から戻る
- 処理内容
  1. V-Blankの開始を待ち、LCDを停止
  2. VRAMの背景マップ領域をタイルミラー領域からコピーする形で復帰
  3. VRAMのタイルパターンテーブルを初期化(元に戻す)
  4. LCD再開
  5. return

### 注意事項
- `view_img()`から`quit_img()`の間、tdqへエンキューしないこと
